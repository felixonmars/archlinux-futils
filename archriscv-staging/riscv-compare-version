#!/usr/bin/python

from collections import defaultdict
from functools import partial
import glob
import os
import pyalpm
import sys
import time

RVDBDIR = sys.argv[1]
REPOROOT = sys.argv[2]
PATCHREPO = sys.argv[3]

x86_handle = pyalpm.Handle(".", "/var/lib/pacman")
rv_handle = pyalpm.Handle(".", f"{RVDBDIR}")

rv_packages = defaultdict(dict)
x86_packages = defaultdict(dict)
pkgbase_map = defaultdict(set)

rv_provides = set()

version_mismatch = set()
db_mismatch = set()

blacklist = set()

with open(PATCHREPO + "/blacklist.txt") as f:
    for pkg in f:
        pkg = pkg.rstrip("\n")
        if pkg.startswith("#") or not pkg:
            continue
        blacklist.add(pkg)

print("""
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
<style>
tr:hover { background-color: #ddd !important; }
.tag.tag-with-details { height: auto; min-height: 2em; }
</style>
<table class="table is-hoverable">
<thead><tr><th>DB</th><th>Package</th><th>Status</th></tr></thead><tbody>
""")

def read_db(handle, db, result, build_pkgbase_map=False, check_duplicate=False, check_file=False):
    db_handle = handle.register_syncdb(db, 0)
    for package in db_handle.search(""):
        if check_file:
            if not os.path.exists(f"{REPOROOT}/repo/{db}/{package.filename}"):
                print(f"<tr><td>{db}</td><td>{package.name}</td><td><font color=red>Lint: package file not found in repository</font></td></tr>")
            elif not os.path.exists(f"{REPOROOT}/repo/{db}/{package.filename}.sig"):
                print(f"<tr><td>{db}</td><td>{package.name}</td><td><font color=red>Lint: package signature not found in repository</font></td></tr>")
        if check_duplicate and package.name in result:
            print(f"<tr><td>{db}</td><td>{package.name}</td><td><font color=red>Lint: package found in different repository: {result[package.name]['db']}. x86 repo: {x86_packages[package.name]['db']}</font></td></tr>")
        for field in ("depends", "makedepends", "checkdepends", "provides", "arch", "base", "version"):
            result[package.name][field] = getattr(package, field)
        result[package.name]["db"] = db
        if build_pkgbase_map:
            pkgbase_map[result[package.name]["base"]].add(package.name)

for db in ["core", "extra", "community"]:
    read_db(x86_handle, db, x86_packages, build_pkgbase_map=True)
    read_db(rv_handle, db, rv_packages, check_duplicate=True, check_file=True)

rv_provides |= set(rv_packages)

for pkgname, package in rv_packages.copy().items():
    rvver = package["version"]

    if "." in rvver.split("-")[1]:
        rvver = "-".join((rvver.split("-")[0], rvver.split("-")[1].split(".")[0]))

    if pkgname in x86_packages:
        if rvver != x86_packages[pkgname]["version"]:
            version_mismatch.add(pkgname)

    for _package in package["provides"]:
        rv_provides.add(_package.split("=")[0])

def x86_history_link(package, db):
    if db in ["community"]:
        repo = 'community'
    elif db in ["core", "extra"]:
        repo = 'packages'
    else:
        repo = 'unsupported'
    return f"https://github.com/archlinux/svntogit-{repo}/commits/packages/{package}/trunk"

def patch_repo_link(package):
    if os.path.exists(f"{PATCHREPO}/{package}"):
        return f" <a href=https://github.com/felixonmars/archriscv-packages/tree/master/{package}><span class='tag is-info'>patched</span></a>"
    else:
        return ""

def parse_build_log(log):
    stages = [
        ("patch failed", "\x1b[1m\x1b[32m==>\x1b[m\x0f\x1b[1m Applying RISC-V patches...\x1b[m\x0f"),
        ("source download failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Failure while downloading"),
        ("checksum mismatch", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m One or more files did not pass the validity check"),
        ("gpg failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m One or more PGP signatures"),
        ("dependency missing", "\x1b[?25h\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Could not resolve all dependencies"),
        ("dependency missing", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m Could not resolve all dependencies."),
        ("prepare() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in prepare()."),
        ("build() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in build()."),
        ("check() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in check()."),
        ("package() failed", "\x1b[1m\x1b[31m==> ERROR:\x1b[m\x0f\x1b[1m A failure occurred in package"),
        ("old config.guess", "configure: error: cannot guess build type; you must specify one"),
        ("broken rust target", "  error: Error loading target specification: Could not find specification for target \"riscv64-unknown-linux-gnu\".")
    ]
    last_failed_stage = None
    with open(log, errors="backslashreplace") as f:
        for line in f:
            for stage, prefix in stages.copy():
                if line.startswith(prefix):
                    last_failed_stage = stage
                    # Only check stages after the last failed stage for the following lines
                    for stage, prefix in stages.copy():
                        stages.remove((stage, prefix))
                        if stage == last_failed_stage:
                            break
    return last_failed_stage


broken_pkgs = set()
outdated_logs = set()
old_log_threshold = time.time() - 30 * 24 * 60 * 60
for pkgname, package in x86_packages.items():
    if os.path.exists(f"{REPOROOT}/.status/logs/{package['base']}"):
        if pkgname in rv_packages:
            rvver = rv_packages[pkgname]["version"]
            if "." in rvver.split("-")[1]:
                rvver = "-".join((rvver.split("-")[0], rvver.split("-")[1].split(".")[0]))
            if rvver == package["version"]:
                continue

        if os.path.isfile(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log"):
            pass
        elif glob.glob(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}-*.log"):
            pass
        else:
            outdated_logs |= pkgbase_map[package['base']]
            continue

        broken_pkgs.add(pkgname)

def missing_dep(pkgbase):
    check_pkgs = set()
    for pkgname in pkgbase_map[pkgbase]:
        package = x86_packages[pkgname]
        check_pkgs |= set(package["depends"] + package["makedepends"] + package["checkdepends"])

    missing = set()
    broken = set()
    outdated = set()
    for dep in check_pkgs:
        for _c in "<", ">", "=":
            dep = dep.split(_c)[0]
        if dep not in rv_provides and dep not in pkgbase_map[pkgbase]:
            missing.add(dep)
        elif dep in broken_pkgs:
            broken.add(dep)
        elif dep in version_mismatch:
            outdated.add(dep)

    return missing, broken, outdated


def make_link(list, package):
    return f"<li><a href='#{package}'>{package}</a></li>" if list else f"<a href='#{package}'>{package}</a>"

def make_tag_with_details(pkg_set, label, category):
    def get_config(pkg_set):
        # config: use_list, separator, content_before, content_after
        if len(pkg_set) <= 2:
            return False, ', ', '', ''
        else:
            return True, '', '<details><ul>', '</ul></details>'
    use_list, separator, content_before, content_after = get_config(pkg_set)
    return f" <span class='tag tag-with-details is-{category}'>" + \
        f"{label}: {content_before}{separator.join(map(partial(make_link, use_list), pkg_set))}{content_after}</span>"
    
def render_missing_dep(pkgbase, show_leaf=False):
    verstr = ""
    missing, broken, outdated = missing_dep(pkgbase)

    if missing:
        verstr += make_tag_with_details(missing, 'DEP MISSING', 'danger')
    if broken:
        verstr += make_tag_with_details(broken, 'DEP BROKEN', 'danger')
    if outdated:
        verstr += make_tag_with_details(outdated, 'DEP OUTDATED', 'warning')

    if show_leaf and not verstr:
        verstr += "Leaf package, port it!"

    if pkgname in outdated_logs:
        verstr += f" <a href='logs/{pkgbase}/'><span class='tag is-light'>Outdated FTBFS Logs</span></a>"
    return verstr


for pkgname in sorted(broken_pkgs):
    package = x86_packages[pkgname]
    ftbfs_link = f"logs/{package['base']}/"
    log_marks = render_missing_dep(package["base"])
    if os.path.isfile(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log"):
        ftbfs_link = f"logs/{package['base']}/{package['base']}-{package['version']}.log"
        if os.path.getmtime(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log") < old_log_threshold:
            log_marks += " <span class='tag is-warning'>old</span>"
        failed_stage = parse_build_log(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}.log")
        if failed_stage:
            log_marks += f" <span class='tag is-danger'>{failed_stage}</span>"
    elif glob.glob(f"{REPOROOT}/.status/logs/{package['base']}/{package['base']}-{package['version']}-*.log"):
        log_marks += " <span class='tag is-warning'>old format</span>"

    pkgname_str = pkgname
    if pkgname != package['base']:
        pkgname_str += f" ({package['base']})"

    print(f"<tr id='{pkgname}'><td>{package['db']}</td><td>{pkgname_str}</td><td><a href='{ftbfs_link}'>"
          f"<span class='tag is-danger'>FTBFS</span></a>{log_marks + patch_repo_link(package['base'])}</td></tr>")


for pkgname in sorted(version_mismatch):
    if pkgname in broken_pkgs:
        continue
    db = x86_packages[pkgname]['db']
    pkgbase = x86_packages[pkgname]['base']
    rvver = rv_packages[pkgname]["version"]
    x86ver = x86_packages[pkgname]['version']
    cmp = pyalpm.vercmp(rvver, x86ver)
    if cmp < 0:
        rvpkgver = rvver.split("-")[0]
        x86pkgver = x86ver.split("-")[0]
        if rvpkgver == x86pkgver:
            rvpkgrel = rvver.split("-")[1]
            x86pkgrel = x86ver.split("-")[1]
            verstr = f"{rvpkgver}-<font color=green>{rvpkgrel} -> </font>{x86pkgver}-<font color=green>{x86pkgrel}</font>"
        else:
            verstr = f"<font color=green>{rvver} -> {x86ver}</font>"
    elif cmp > 0:
        verstr = f"<font color=orange>{rvver} <- {x86ver}</font>"
    verstr += f" <a href={x86_history_link(pkgbase, db)}><span class='tag is-info'>Changes</span></a>"

    verstr += render_missing_dep(pkgbase)

    verstr += patch_repo_link(pkgbase)

    pkgname_str = pkgname
    if pkgname != pkgbase:
        pkgname_str += f" ({pkgbase})"

    print(f"<tr id='{pkgname}'><td>{db}</td><td>{pkgname_str}</td><td>{verstr}</td></tr>")

for pkgname, package in x86_packages.items():
    if pkgname in rv_packages or pkgname in broken_pkgs or pkgname in blacklist:
        continue

    pkgname_str = pkgname
    if pkgname != package['base']:
        pkgname_str += f" ({package['base']})"

    verstr = render_missing_dep(package['base'], show_leaf=True)
    verstr += patch_repo_link(package['base'])
    print(f"<tr id='{pkgname}'><td>{package['db']}</td><td>{pkgname_str}</td><td>{verstr}</td></tr>")

for pkgname, package in rv_packages.items():
    if pkgname not in x86_packages:
        print(f"<tr><td>{package['db']}</td><td>{pkgname}</td><td><font color=yellow>Lint: package not found in x86 repository.</font></td></tr>")
    elif x86_packages[pkgname]["db"] != package["db"]:
        print(f"<tr><td>{package['db']}</td><td>{pkgname}</td><td><font color=red>Lint: package in different x86 repository: {x86_packages[pkgname]['db']}.</font></td></tr>")

print('</tbody></table>')
